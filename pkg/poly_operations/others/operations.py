from shapely.geometry import LinearRing
from ...poly_operations.others import adjacency as adj


def fuse_polys_around_v(v, decomposition):
	"""
	Fuse all cells that contain the vertex forming one cell.

	[TODO]: Combine the polygons such that holes are retained.

	:param v: The vertex.
	:param decomposition: A decomposition containing a lis of cells. Modified
							in place

	:return poly_union: A resultant cell that was generated by fusing all
						containing cells.
	"""

	poly_union = []
	poly_union_idx = []

	adjacency = adj.compute_adjacency_matrix(decomposition)
	shared_polys_tuples = find_containing_polys(v, adjacency)

	# Combining cells until all of them are combined
	while shared_polys_tuples:

		poly_a_id, poly_b_id, edge = shared_polys_tuples.pop(0)

		# The very first iteration, don't do checks
		if not poly_union_idx:
			poly_a = decomposition[poly_a_id][0]
			poly_b = decomposition[poly_b_id][0]
			
			poly_union_idx.append(poly_a_id)
			poly_union_idx.append(poly_b_id)

			poly_union = combine_adjacent_polys(poly_a, poly_b, edge)
		else:	
			if poly_a_id in poly_union_idx:
				poly_b = decomposition[poly_b_id][0]
				poly_union_idx.append(poly_b_id)

				poly_union = combine_adjacent_polys(poly_union, poly_b, edge)

			elif poly_b_id  in poly_union_idx:
				poly_a = decomposition[poly_a_id][0]
				poly_union_idx.append(poly_a_id)

				poly_union = combine_adjacent_polys(poly_union, poly_a, edge)
			else:
				shared_polys_tuples.append((poly_a_id, poly_b_id, edge))

	# Modify to standard form of a polygon
	if poly_union:
		return [poly_union, []], poly_union_idx
	else:
		return [], []


def find_containing_polys(v, adj):
	"""
	Function find all cells in adjacency matrix that share a vertex.

	:param v: A vertex in question.
	:param adj: Adjacency matrix.
	
	:return edge_tuples: A list of shared edge tuples.
	"""
	
	shared_edge_tuples = []

	for i in range(len(adj)):
		for j in range(i, len(adj)):

			if not adj[i][j] is None:
				if v[1] in adj[i][j]:
					shared_edge_tuples.append((i, j, adj[i][j]))

	return shared_edge_tuples


def combine_adjacent_polys(p1, p2, e):
	"""
	Combines the chains of two adjacent polygons.

	Note: assumption is made that p1 and p2 are adjacent.

	:param p1: Polygon one.
	:param p2: Polygon two.
	:param e: Shared edge.

	:return polygon: Resultant polygon.
	"""

	v, w = e

	# Make sure the last and first verticies are not same
	if p1[0] == p1[-1]:
		p1 = p1[:-1]
	if p2[0] == p2[-1]:
		p2 = p2[:-1]

	# Error prone step, doesnt always succeeds.
	p1_v_idx = p1.index(v)
	p2_v_idx = p2.index(v)

	p1_w_idx = p1.index(w)
	p2_w_idx = p2.index(w)

	# Combination logic depending on where v, w are.
	if (p1_v_idx == 0) and (p1_w_idx == 1):
		left_chain = p1[1:]+[p1[0]]
	elif (p1_v_idx == 0) and (p1_w_idx == len(p1)-1):
		left_chain = p1[:]
	elif (p1_w_idx == 0) and (p1_v_idx == 1):
		left_chain = p1[1:]+[p1[0]]
	elif (p1_w_idx == 0) and (p1_v_idx == len(p1)-1):
		left_chain = p1[:]
	elif p1_v_idx < p1_w_idx:
		left_chain = p1[p1_w_idx:]+p1[:p1_v_idx+1]
	elif p1_w_idx < p1_v_idx:
		left_chain = p1[p1_v_idx:]+p1[:p1_w_idx+1]

	if (p2_v_idx == 0) and (p2_w_idx == 1):
		right_chain = p2[2:]
	elif (p2_v_idx == 0) and (p2_w_idx == len(p2)-1):
		right_chain = p2[1:-1]
	elif (p2_w_idx == 0) and (p2_v_idx == 1):
		right_chain = p2[2:]
	elif (p2_w_idx == 0) and (p2_v_idx == len(p2)-1):
		right_chain = p2[1:-1]	
	elif p2_v_idx < p2_w_idx:
		right_chain = p2[p2_w_idx+1:]+p2[:p2_v_idx]
	elif p2_w_idx < p2_v_idx:
		right_chain = p2[p2_v_idx+1:]+p2[:p2_w_idx]

	lr_left = LinearRing(p1)
	lr_right = LinearRing(p2)

	if lr_left.is_ccw:
		if lr_right.is_ccw:
			fuse = left_chain+right_chain
		else:
			fuse = left_chain+right_chain[::-1]
	else:
		if lr_right.is_ccw:
			fuse = left_chain+right_chain[::-1]
		else:
			fuse = left_chain+right_chain

	return fuse


def find_cut_edge(p1, p2, v):
	"""
	Find a shared edge between two polygons
	"""

	idx_1 = p1.index(v)
	idx_2 = p2.index(v)

	p1_edge_1 = [p1[idx_1], p1[(idx_1+1)%len(p1)]]
	p1_edge_2 = [p1[idx_1], p1[(idx_1-1)%len(p1)]]

	p2_edge_1 = [p2[idx_2], p2[(idx_2+1)%len(p2)]]
	p2_edge_2 = [p2[idx_2], p2[(idx_2-1)%len(p2)]]

	if p1_edge_1 == p2_edge_1:
		return p1_edge_1
	elif p1_edge_1 == p2_edge_2:
		return p1_edge_1
	elif p1_edge_2 == p2_edge_1:
		return p1_edge_2
	elif p1_edge_2 == p2_edge_2:
		return p1_edge_2

	print("[ERROR] Something went wrong and shared edge was not found!")


def find_common_polys(D, v):

	found_polys = []
	for poly in D:
		if v in poly:
			found_polys.append(poly)

	if len(found_polys) > 2:
		print("[ERROR] Something went wrong, more than one polys!")

	return found_polys[0], found_polys[1]